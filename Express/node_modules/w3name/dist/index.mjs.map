{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * A client library for the w3name - IPNS over HTTP API. It provides a\n * convenient interface for creating names, making revisions to name records,\n * and publishing and resolving them via the HTTP API.\n *\n * @example\n * ```js\n * import * as Name from 'w3name'\n *\n * const name = await Name.create()\n *\n * console.log('Name:', name.toString())\n * // e.g. k51qzi5uqu5di9agapykyjh3tqrf7i14a7fjq46oo0f6dxiimj62knq13059lt\n *\n * // The value to publish\n * const value = '/ipfs/bafkreiem4twkqzsq2aj4shbycd4yvoj2cx72vezicletlhi7dijjciqpui'\n * const revision = await Name.v0(name, value)\n *\n * // Publish the revision\n * await Name.publish(revision, name.key)\n *\n * // Resolve the latest value\n * await Name.resolve(name)\n * ```\n * @module\n */\n\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { keys, PrivateKey, PublicKey } from 'libp2p-crypto'\nimport { identity } from 'multiformats/hashes/identity'\nimport { base36 } from 'multiformats/bases/base36'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as ipns from 'ipns'\nimport * as cbor from 'cborg'\nimport W3NameService from './service'\nimport fetch from '@web-std/fetch'\n\nconst libp2pKeyCode = 0x72\nconst ONE_YEAR = 1000 * 60 * 60 * 24 * 365\n\nconst defaultValidity = (): string => new Date(Date.now() + ONE_YEAR).toISOString()\n\nconst defaultService = new W3NameService()\n/**\n * Name is an IPNS key ID.\n *\n * Names can be used to retrieve the latest published value from the W3name service\n * using the {@link resolve} function.\n *\n * Note that `Name` contains only the public verification key and does not allow publishing\n * or updating records. To create or update a record, use the {@link WritableName} subclass.\n *\n * To convert from a string representation of a name to a `Name` object use the {@link parse} function.\n */\nexport class Name {\n  /** @internal */\n  _pubKey: PublicKey\n\n  constructor (pubKey: PublicKey) {\n    /**\n     * @private\n     */\n    this._pubKey = pubKey\n  }\n\n  /**\n   * A binary representation of the IPNS verification key.\n   */\n  get bytes (): Uint8Array {\n    const digest = Digest.create(identity.code, this._pubKey.bytes)\n    return CID.createV1(libp2pKeyCode, digest).bytes\n  }\n\n  /**\n   * @returns the string representation of the IPNS verification key (e.g. `k51qzi5uqu5di9agapykyjh3tqrf7i14a7fjq46oo0f6dxiimj62knq13059lt`)\n   */\n  toString (): string {\n    const digest = Digest.create(identity.code, this._pubKey.bytes)\n    return CID.createV1(libp2pKeyCode, digest).toString(base36)\n  }\n}\n\n/**\n * WritableName is a {@link Name} that has a signing key associated with it such that\n * new IPNS record {@link Revision}s can be created and signed for it.\n *\n * New `WritablName`s can be generated using the {@link create} function.\n *\n * To load a `WritableName` from a saved binary representation, see {@link from}.\n */\nexport class WritableName extends Name {\n  /** @internal */\n  _privKey: PrivateKey\n\n  constructor (privKey: PrivateKey) {\n    super(privKey.public)\n    /**\n     * @private\n     */\n    this._privKey = privKey\n  }\n\n  /**\n   * The private signing key, as a libp2p `PrivateKey` object.\n   *\n   * To save a key for later loading with {@link from}, write the\n   * contents of `key.bytes` somewhere safe.\n   */\n  get key (): PrivateKey {\n    return this._privKey\n  }\n}\n\n/**\n * Create a new name with associated signing key that can be used to create and\n * publish IPNS record revisions.\n */\nexport async function create (): Promise<WritableName> {\n  const privKey = await keys.generateKeyPair('Ed25519', 2048)\n  return new WritableName(privKey)\n}\n\n/**\n * Parses a string-encoded {@link Name} to a {@link Name} object.\n *\n * Note that this returns a read-only {@link Name}, which can be used to {@link resolve} values\n * but cannot {@link publish} them.\n */\nexport function parse (name: string): Name {\n  const keyCid = CID.parse(name, base36)\n  if (keyCid.code !== libp2pKeyCode) {\n    throw new Error(`Invalid key, expected ${libp2pKeyCode} codec code but got ${keyCid.code}`)\n  }\n  const pubKey = keys.unmarshalPublicKey(Digest.decode(keyCid.multihash.bytes).bytes)\n  return new Name(pubKey)\n}\n\n/**\n * Creates a {@link WritableName} from an existing signing key (private key).\n *\n * Expects the given `Uint8Array` to contain a binary representation of a\n * private signing key. Note that this is **not** the same as the output of\n * {@link Name#bytes | Name.bytes}, which always returns an encoding of the _public_ key,\n * even when the name in question is a {@link WritableName}.\n *\n * To save the key for a {@link WritableName} so that it can be used with this\n * function, use `key.bytes`, for example:\n *\n * @example\n * ```js\n * import * as Name from 'w3name'\n * import fs from 'fs'\n *\n * async function example() {\n *   const myName = await Name.create()\n *\n *   // myName.key.bytes can now be written to disk / database, etc.\n *   await fs.promises.writeFile('myName.key', myName.key.bytes)\n *\n *   // let's pretend some time has passed and we want to load the\n *   // key from disk:\n *   const loadedBytes = await fs.promises.readFile('myName.key')\n *   const myName2 = await Name.from(loadedBytes)\n *\n *   // myName and myName2 can now be used interchangeably\n * }\n * ```\n *\n */\nexport async function from (key: Uint8Array): Promise<WritableName> {\n  const privKey = await keys.unmarshalPrivateKey(key)\n  return new WritableName(privKey)\n}\n\n/**\n * Create an initial version of the IPNS record for the passed {@link Name}, set to the\n * passed value.\n *\n * Note that the returned {@link Revision} object must be {@link publish}ed before it\n * can be {@link resolve}d using the service.\n */\nexport async function v0 (name: Name, value: string): Promise<Revision> {\n  return new Revision(name, value, 0n, defaultValidity())\n}\n\n/**\n * Create a {@link Revision} of the passed IPNS record by incrementing the sequence\n * number and changing the value.\n *\n * This returns a new {@link Revision} and  does not alter the original `revision` argument.\n */\nexport async function increment (revision: Revision, value: string): Promise<Revision> {\n  const seqno = revision.sequence + 1n\n  return new Revision(revision.name, value, seqno, defaultValidity())\n}\n\n/**\n * A representation of a IPNS record that may be initial or revised.\n */\nexport class Revision {\n  /** @internal */\n  _name: Name\n\n  /** @internal */\n  _value: string\n\n  /** @internal */\n  _sequence: bigint\n\n  /** @internal */\n  _validity: string\n\n  constructor (name: Name, value: string, sequence: bigint, validity: string) {\n    this._name = name\n    if (typeof value !== 'string') {\n      throw new Error('invalid value')\n    }\n    this._value = value\n    if (typeof sequence !== 'bigint') {\n      throw new Error('invalid sequence number')\n    }\n    this._sequence = sequence\n    if (typeof validity !== 'string') {\n      throw new Error('invalid validity')\n    }\n    // TODO: validate format\n    this._validity = validity\n  }\n\n  get name (): Name {\n    return this._name\n  }\n\n  get value (): string {\n    return this._value\n  }\n\n  get sequence (): bigint {\n    return this._sequence\n  }\n\n  /**\n   * RFC3339 date string.\n   */\n  get validity (): string {\n    return this._validity\n  }\n\n  /**\n   * Encodes a `Revison` to a binary representation and returns it as a `Uint8Array`.\n   *\n   * Note: if `revision.name` is a `WritableName` then signing key data will be\n   * lost. i.e. the private key is not encoded.\n   */\n  static encode (revision: Revision): Uint8Array {\n    return cbor.encode({\n      name: revision._name.toString(),\n      value: revision._value,\n      sequence: revision._sequence,\n      validity: revision._validity\n    })\n  }\n\n  /**\n   * Decodes a `Revison` from a binary representation.\n   *\n   * @param bytes - a `Uint8Array` containing a binary encoding of a `Revison`, as produced by {@link #encode}.\n   * @returns a {@link Revision} object\n   * @throws if `bytes` does not contain a valid encoded `Revision`\n   */\n  static decode (bytes: Uint8Array): Revision {\n    const raw = cbor.decode(bytes)\n    const name = parse(raw.name)\n    return new Revision(name, raw.value, BigInt(raw.sequence), raw.validity)\n  }\n}\n\n/**\n * Publish a name {@link Revision} to W3name.\n *\n * Names should be {@link resolve}-able immediately via the w3name service, and will be\n * provided to the IPFS DHT network.\n *\n * Note that it may take a few seconds for the record to propagate and become available via\n * the IPFS DHT network and IPFS <-> HTTP gateways.\n */\nexport async function publish (revision: Revision, key: PrivateKey, service: W3NameService = defaultService): Promise<void> {\n  const url = new URL(`name/${revision.name.toString()}`, service.endpoint)\n  const entry = await ipns.create(\n    key,\n    uint8ArrayFromString(revision.value),\n    revision.sequence,\n    new Date(revision.validity).getTime() - Date.now()\n  )\n  await service.waitForRateLimit()\n  await maybeHandleError(fetch(url.toString(), {\n    method: 'POST',\n    body: uint8ArrayToString(ipns.marshal(entry), 'base64pad')\n  }))\n}\n\n/**\n * Resolve the current IPNS record revision for the passed name.\n *\n * Note that this will only resolve names published using the W3name service. Names published by\n * other IPNS implementations should be resolved using a DHT-backed implementation (e.g. kubo, js-ipfs, etc).\n */\nexport async function resolve (name: Name, service: W3NameService = defaultService): Promise<Revision> {\n  const url = new URL(`name/${name.toString()}`, service.endpoint)\n  await service.waitForRateLimit()\n\n  const res: globalThis.Response = await maybeHandleError(fetch(url.toString()))\n  const { record } = await res.json()\n\n  const entry = ipns.unmarshal(uint8ArrayFromString(record, 'base64pad'))\n  const keyCid = CID.decode(name.bytes)\n  const pubKey = keys.unmarshalPublicKey(Digest.decode(keyCid.multihash.bytes).bytes)\n\n  await ipns.validate(pubKey, entry)\n\n  return new Revision(\n    name,\n    uint8ArrayToString(entry.value),\n    entry.sequence,\n    uint8ArrayToString(entry.validity)\n  )\n}\n\nasync function maybeHandleError (resPromise: Promise<globalThis.Response>): Promise<globalThis.Response> {\n  const res = await resPromise\n  if (res.ok) return res\n  let error\n  try {\n    const parsedError = await res.json()\n    error = new Error(parsedError.message)\n  } catch (jsonParseError) {\n    error = new Error(`unexpected response from API, cannot parse error response. Received status: ${res.status}`)\n  }\n  throw error\n}\n"],"names":["defaultValidity","Date","now","toISOString","defaultService","W3NameService","Name","constructor","pubKey","this","_pubKey","bytes","digest","Digest","create","identity","code","CID","createV1","toString","base36","WritableName","privKey","super","public","_privKey","key","async","keys","generateKeyPair","parse","name","keyCid","Error","unmarshalPublicKey","decode","multihash","from","unmarshalPrivateKey","v0","value","Revision","increment","revision","seqno","sequence","validity","_name","_value","_sequence","_validity","static","cbor","encode","raw","BigInt","publish","service","url","URL","endpoint","entry","ipns","uint8ArrayFromString","getTime","waitForRateLimit","maybeHandleError","fetch","method","body","uint8ArrayToString","marshal","resolve","res","record","json","unmarshal","validate","resPromise","ok","error","parsedError","message","jsonParseError","status"],"mappings":"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"}