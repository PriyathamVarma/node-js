import{fromString as e}from"uint8arrays/from-string";import{toString as t}from"uint8arrays/to-string";import{keys as n}from"libp2p-crypto";import{identity as r}from"multiformats/hashes/identity";import{base36 as i}from"multiformats/bases/base36";import{CID as a}from"multiformats/cid";import*as s from"multiformats/hashes/digest";import*as o from"ipns";import*as c from"cborg";import u from"./service.mjs";import m from"@web-std/fetch";const d=()=>new Date(Date.now()+31536e6).toISOString(),y=new u;class l{constructor(e){this._pubKey=e}get bytes(){const e=s.create(r.code,this._pubKey.bytes);return a.createV1(114,e).bytes}toString(){const e=s.create(r.code,this._pubKey.bytes);return a.createV1(114,e).toString(i)}}class w extends l{constructor(e){super(e.public),this._privKey=e}get key(){return this._privKey}}async function p(){const e=await n.generateKeyPair("Ed25519",2048);return new w(e)}function f(e){const t=a.parse(e,i);if(114!==t.code)throw new Error(`Invalid key, expected 114 codec code but got ${t.code}`);const r=n.unmarshalPublicKey(s.decode(t.multihash.bytes).bytes);return new l(r)}async function h(e){const t=await n.unmarshalPrivateKey(e);return new w(t)}async function v(e,t){return new g(e,t,0n,d())}async function b(e,t){const n=e.sequence+1n;return new g(e.name,t,n,d())}class g{constructor(e,t,n,r){if(this._name=e,"string"!=typeof t)throw new Error("invalid value");if(this._value=t,"bigint"!=typeof n)throw new Error("invalid sequence number");if(this._sequence=n,"string"!=typeof r)throw new Error("invalid validity");this._validity=r}get name(){return this._name}get value(){return this._value}get sequence(){return this._sequence}get validity(){return this._validity}static encode(e){return c.encode({name:e._name.toString(),value:e._value,sequence:e._sequence,validity:e._validity})}static decode(e){const t=c.decode(e),n=f(t.name);return new g(n,t.value,BigInt(t.sequence),t.validity)}}async function _(n,r,i=y){const a=new URL(`name/${n.name.toString()}`,i.endpoint),s=await o.create(r,e(n.value),n.sequence,new Date(n.validity).getTime()-Date.now());await i.waitForRateLimit(),await S(m(a.toString(),{method:"POST",body:t(o.marshal(s),"base64pad")}))}async function q(r,i=y){const c=new URL(`name/${r.toString()}`,i.endpoint);await i.waitForRateLimit();const u=await S(m(c.toString())),{record:d}=await u.json(),l=o.unmarshal(e(d,"base64pad")),w=a.decode(r.bytes),p=n.unmarshalPublicKey(s.decode(w.multihash.bytes).bytes);return await o.validate(p,l),new g(r,t(l.value),l.sequence,t(l.validity))}async function S(e){const t=await e;if(t.ok)return t;let n;try{const e=await t.json();n=new Error(e.message)}catch(e){n=new Error(`unexpected response from API, cannot parse error response. Received status: ${t.status}`)}throw n}export{l as Name,g as Revision,w as WritableName,p as create,h as from,b as increment,f as parse,_ as publish,q as resolve,v as v0};
//# sourceMappingURL=index.mjs.map
